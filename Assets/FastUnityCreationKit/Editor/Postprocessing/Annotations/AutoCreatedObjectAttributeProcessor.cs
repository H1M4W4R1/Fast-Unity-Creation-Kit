using System;
using System.Reflection;
using FastUnityCreationKit.Annotations.Unity;
using FastUnityCreationKit.Annotations.Utility;
using FastUnityCreationKit.Editor.Postprocessing.Abstract;
using FastUnityCreationKit.Editor.Postprocessing.Interfaces;
using FastUnityCreationKit.Core.Logging;
using JetBrains.Annotations;
using Sirenix.Utilities;
using UnityEditor;
using UnityEngine;

namespace FastUnityCreationKit.Editor.Postprocessing.Annotations
{
    [Order(int.MinValue)] // ALWAYS FIRST!
    [UsedImplicitly]
    public sealed class AutoCreatedObjectAttributeProcessor : QuickAssetProcessor<AutoCreatedObjectAttributeProcessor>,
        IPostprocessAllAssets
    {
        public const string ROOT_PATH = "Assets/AutoGenerated";

        protected override bool AssetIsRequired => false;

        /// <summary>
        /// Count scripts modified in specified assets.
        /// </summary>
        private static int CountScripts([NotNull] string[] assets)
        {
            // Count scripts
            int count = 0;
            for (int index = 0; index < assets.Length; index++)
            {
                string asset = assets[index];
                if (asset.EndsWith(".cs", StringComparison.Ordinal)) count++;
            }

            return count;
        }

        public void PostprocessAllAssets([NotNull] string[] importedAssets,
            [NotNull] string[] deletedAssets,
            [NotNull] string[] movedAssets,
            [NotNull] string[] movedFromAssetPaths)
        {
            if (movedFromAssetPaths == null) throw new ArgumentNullException(nameof(movedFromAssetPaths));
            // We are primarily interested in new and deleted scripts 
            int totalCount = CountScripts(importedAssets) + CountScripts(deletedAssets) + CountScripts(movedAssets);
            Guard<ValidationLogConfig>.Verbose($"Processing scripts. Found {totalCount} modifications.");

            // Check if any scripts were altered
            if (totalCount == 0) return;
            Guard<ValidationLogConfig>.Verbose("Scripts modifications found, searching for objects to create.");

            PerformAutoCreateObjectProcessing();
        }

        /// <summary>
        /// Perform processing of all assemblies.
        /// </summary>
        internal static void PerformAutoCreateObjectProcessing()
        {
            // Get all assemblies
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            // Process all assemblies
            foreach (Assembly assembly in assemblies)
                ProcessAssembly(assembly);
        }

        private static void ProcessAssembly([NotNull] Assembly assembly)
        {
            int createdCount = 0;

            // Process all types with the custom attribute 
            foreach (Type type in assembly.GetTypes())
            {
                // Check if type is abstract or interface  
                if (type.IsInterface || type.IsAbstract) continue;

                (bool success, ScriptableObject _) = TryCreateScriptableObject(type);
                if (success) createdCount++;
            }

            // Log the number of created assets 
            if (createdCount > 0)
                Guard<ValidationLogConfig>.Debug($"Created {createdCount} assets from assembly {assembly.FullName}.");

            // Save assets that were created we do this to ensure that the assets are saved
            AssetDatabase.SaveAssets();
        }


        /// <summary>
        /// Tries to create a scriptable object from the specified type.
        /// </summary>
        private static (bool, ScriptableObject) TryCreateScriptableObject(Type type)
        {
            // Check if type is scriptable object 
            if (!typeof(ScriptableObject).IsAssignableFrom(type)) return (false, null);

            // Check if type has AutoCreatedObjectAttribute
            AutoCreatedObjectAttribute attribute = CustomAttributeExtensions.GetCustomAttribute<AutoCreatedObjectAttribute>(type, true);
            if (attribute == null) return (false, null);

            // Ensure type is sealed, if not log warning and process further
            if (!type.IsSealed)
            {
                Guard<ValidationLogConfig>.Warning(
                    $"Type {type.FullName} is not sealed. Non-sealed types are unsafe. Please add 'sealed' keyword to the class.");
            }

            // We can't create generic types, this will result in big no-no
            // Abstract generic types are fine because they won't pass to this check
            // as are ignored earlier. 
            if (type.IsGenericType)
            {
                Guard<ValidationLogConfig>.Error(
                    $"Type {type.FullName} is generic. Generic types are not supported for auto-creation.");
                return (false, null);
            }

            // Get path to asset
            string assetDirectory = ValidateAndGetDirectoryPath(attribute);

            // Check if asset already exists
            // Skip if it does
            if (CheckIfExists(assetDirectory, type)) return (false, null);

            // Create scriptable object   
            ScriptableObject obj = ScriptableObject.CreateInstance(type);

            // Save object 
            // Get postprocessor instance 
            CreateAsset($"{assetDirectory}{NameOf(type)}.asset", obj);
            Guard<ValidationLogConfig>.Debug($"Created {type.FullName} at {assetDirectory}{NameOf(type)}.asset");

            return (true, obj);
        }

        [NotNull] private static string ValidateAndGetDirectoryPath([NotNull] AutoCreatedObjectAttribute attribute)
        {
            string subDirectory = attribute.SubDirectory;

            // Check if root directory exists
            if (!AssetDatabase.IsValidFolder(ROOT_PATH))
                AssetDatabase.CreateFolder("Assets", "AutoGenerated");

            string currentPath = ROOT_PATH;

            // Check if sub directory exists
            string[] splitDir = subDirectory.Replace('\\', '/').Split('/');

            // Create sub directories
            for (int j = 0; j < splitDir.Length; j++)
            {
                currentPath = currentPath.TrimEnd('/');

                // Create directory if it doesn't exist  
                if (!AssetDatabase.IsValidFolder(currentPath + "/" + splitDir[j]))
                {
                    AssetDatabase.CreateFolder(currentPath, splitDir[j]);
                    Guard<ValidationLogConfig>.Verbose($"Created missing folder: {currentPath}/{splitDir[j]}");
                }

                // Append new directory to path 
                if (!currentPath.EndsWith('/')) currentPath += '/';
                currentPath += splitDir[j];
            }

            // Ensure directory ends properly
            if (!currentPath.EndsWith('/')) currentPath += '/';

            return currentPath;
        }

        /// <summary>
        /// Checks if the asset already exists.
        /// </summary>
        private static bool CheckIfExists(string path, Type type) =>
            AssetDatabase.LoadAssetAtPath($"{path}{NameOf(type)}.asset", type) != null;

        private static string NameOf(Type type) => type.GetCompilableNiceFullName();
    }
}