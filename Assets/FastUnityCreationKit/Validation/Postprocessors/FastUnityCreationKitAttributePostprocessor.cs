using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using FastUnityCreationKit.Annotations.Attributes;
using FastUnityCreationKit.Data.Abstract;
using FastUnityCreationKit.Data.Containers;
using FastUnityCreationKit.Utility;
using FastUnityCreationKit.Utility.Editor.Extensions;
using FastUnityCreationKit.Utility.Extensions;
using FastUnityCreationKit.Utility.Logging;
using JetBrains.Annotations;
using Sirenix.Utilities;
using UnityEditor;
using UnityEngine;
using UnityEngine.AddressableAssets;
using Assembly = System.Reflection.Assembly;
using Object = UnityEngine.Object;


namespace FastUnityCreationKit.Validation.Postprocessors
{
    public class AutoCreatedObjectDeletionPostprocessor : AssetModificationProcessor
    {
        private static AssetDeleteResult OnWillDeleteAsset(string assetPath, RemoveAssetOptions options)
        {
            // Get asset type
            Type type = AssetDatabase.GetMainAssetTypeAtPath(assetPath);

            // Check if asset is scriptable object
            if (!typeof(ScriptableObject).IsAssignableFrom(type)) return AssetDeleteResult.DidNotDelete;

            // Check if asset has AutoCreatedObjectAttribute
            AutoCreatedObjectAttribute attribute =
                CustomAttributeExtensions.GetCustomAttribute<AutoCreatedObjectAttribute>(type, true);
            if (attribute == null) return AssetDeleteResult.DidNotDelete;

            // Fail deletion
            Guard<ValidationLogConfig>.Warning(
                $"Cannot delete {type.Name} asset. It is marked as auto-created object.");
            return AssetDeleteResult.FailedDelete;
        }

        private static AssetMoveResult OnWillMoveAsset(string sourcePath, string destinationPath)
        {
            // Get asset type
            Type type = AssetDatabase.GetMainAssetTypeAtPath(sourcePath);

            // Check if asset is scriptable object
            if (!typeof(ScriptableObject).IsAssignableFrom(type)) return AssetMoveResult.DidNotMove;

            // Check if asset has AutoCreatedObjectAttribute
            AutoCreatedObjectAttribute attribute =
                CustomAttributeExtensions.GetCustomAttribute<AutoCreatedObjectAttribute>(type, true);
            if (attribute == null) return AssetMoveResult.DidNotMove;

            // Fail move
            Guard<ValidationLogConfig>.Warning(
                $"Cannot move {type.Name} asset. It is marked as auto-created object.");
            return AssetMoveResult.FailedMove;
        }
    }

    public sealed class FastUnityCreationKitAttributePostprocessor : AssetPostprocessor
    {
        public const string ROOT_PATH = "Assets/AutoGenerated";

        private static void OnPostprocessAllAssets(string[] importedAssets,
            string[] deletedAssets,
            string[] movedAssets,
            string[] movedFromAssetPaths)
        {
            // We are primarily interested in new and deleted scripts 
            int totalCount = CountScripts(importedAssets) + CountScripts(deletedAssets) + CountScripts(movedAssets);
            Guard<ValidationLogConfig>.Verbose($"Processing scripts. Found {totalCount} modifications.");

            // Check if any scripts were altered
            if (totalCount == 0) return;
            Guard<ValidationLogConfig>.Verbose("Scripts modifications found, searching for objects to create.");

            PerformAutoCreateObjectProcessing();
        }

        /// <summary>
        /// Count scripts modified in specified assets.
        /// </summary>
        private static int CountScripts(string[] assets)
        {
            // Count scripts
            int count = 0;
            for (int index = 0; index < assets.Length; index++)
            {
                string asset = assets[index];
                if (asset.EndsWith(".cs")) count++;
            }

            return count;
        }

        /// <summary>
        /// Perform processing of all assemblies.
        /// </summary>
        internal static void PerformAutoCreateObjectProcessing()
        {
            // Get all assemblies
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            // Process all assemblies
            foreach (Assembly assembly in assemblies)
                OnAssemblyCompilationFinished(assembly);
        }

        private static void OnAssemblyCompilationFinished(Assembly assembly)
        {
            int createdCount = 0;

            // Load the compiled assembly
            Guard<ValidationLogConfig>.Verbose($"Loaded assembly {assembly.FullName}.");

            List<ScriptableObject> createdAssets = new List<ScriptableObject>();

            // Process all types with the custom attribute 
            foreach (Type type in assembly.GetTypes())
            {
                // Check if type is abstract or interface  
                if (type.IsAbstract || type.IsInterface) continue;

                (bool success, ScriptableObject obj) = TryCreateScriptableObject(type);
                if (success)
                {
                    createdCount++;
                    createdAssets.Add(obj);
                }
            }

            // Process all created assets   
            foreach (ScriptableObject obj in createdAssets)
            {
                TryUpdateAddressableGroup(obj);
                TryToRegisterInContainers(obj);
            }

            // Log the number of created assets 
            if (createdCount > 0)
                Guard<ValidationLogConfig>.Debug($"Created {createdCount} assets from assembly {assembly.FullName}.");

            // Save assets that were created
            // we do this to ensure that the assets are saved
            //
            // We do this after all assets are created
            // to avoid saving assets multiple times
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }

        internal static bool IsAddressableContainer(Type type) => type.ImplementsOpenGenericClass(typeof(AddressableDataContainer<>));

        internal static void TryToRegisterInContainers([NotNull] Object obj)
        {
            Type type = obj.GetType();

            // Check if object has AutoRegisterInAttribute
            IEnumerable<AutoRegisterInAttribute> registerInAttribute =
                CustomAttributeExtensions.GetCustomAttributes<AutoRegisterInAttribute>(type, true);

            // Ensure object is registered in specified databases
            foreach (AutoRegisterInAttribute registerAttribute in registerInAttribute)
            {
                if (obj.IsAddressable())
                {
                    // Addressable object can only be registered in addressable database
                    if (!IsAddressableContainer(registerAttribute.Type))
                    {
                        Guard<ValidationLogConfig>.Error(
                            $"Cannot register {obj.name} in {registerAttribute.Type.Name}. " +
                            $"Type is not a valid AddressableDataContainer.");
                        continue;
                    }
                    
                    TryRegisterInContainer(obj, registerAttribute, GetAddressableObjectToRegister);
                }
                else
                {
                    // Regular object cannot be added to addressable database
                    if (IsAddressableContainer(registerAttribute.Type))
                    {
                        Guard<ValidationLogConfig>.Error(
                            $"Cannot register {obj.name} in {registerAttribute.Type.Name}. " +
                            $"Type is a valid AddressableDataContainer. Object is not addressable.");
                        continue;
                    }
                    
                    TryRegisterInContainer(obj, registerAttribute, SelfObjectReference);    
                }

                
            }
        }

        private static object SelfObjectReference([NotNull] Object obj, [NotNull] Type foundBaseClass,
            AutoRegisterInAttribute registerAttribute) => obj;
        
        internal static bool TryUpdateAddressableGroup([NotNull] Object obj)
        {
            Type type = obj.GetType();

            // Check if object has AddressableGroupAttribute
            AddressableGroupAttribute groupAttribute =
                CustomAttributeExtensions.GetCustomAttribute<AddressableGroupAttribute>(type, true);
            if (groupAttribute != null)
            {
                // Assign object to addressable group, make it read-only
                // to prevent user modifications like changing address.
                if (obj.SetAddressableGroup(groupAttribute.GroupName, true, groupAttribute.Labels))
                    Guard<ValidationLogConfig>.Debug(
                        $"Found AddressableGroupAttribute and assigned {obj.name} to addressable group {groupAttribute.GroupName}");

                return true;
            }

            return false;
        }

        private static void TryRegisterInContainer([NotNull] Object obj, AutoRegisterInAttribute registerAttribute,
            Func<Object, Type, AutoRegisterInAttribute, object> getRegistryObjectRequestAction)
        {
              // Get object type and base type used to define database
            Type type = obj.GetType();
            IEnumerable<Type> baseClasses = type.GetBaseClasses();
            
            Type foundBaseClass = null;

            // Find the first base class that has the specified type
            // without inheritance (this attribute is defined on the base class)
            foreach (Type baseClass in baseClasses)
            {
                IEnumerable<AutoRegisterInAttribute> attributes =
                    baseClass.GetCustomAttributes<AutoRegisterInAttribute>(false);

                // Get first attribute that matches the specified type
                AutoRegisterInAttribute attribute = attributes.FirstOrDefault(a => a.Type == registerAttribute.Type);

                // Check if attribute is not null, if found, assign it to the base class
                if (attribute == null) continue;
                foundBaseClass = baseClass;
                break;
            }

            if (foundBaseClass == null)
            {
                Guard<ValidationLogConfig>.Error(
                    $"Cannot register {obj.name} in {registerAttribute.Type.Name}. " +
                    $"[AutoRegisterIn] not found on any base class.");
                return;
            }

            // Get database type
            Type databaseSubtype = registerAttribute.Type;
            Type databaseType = typeof(AddressableDatabase<,>).MakeGenericType(databaseSubtype, foundBaseClass);

            // Get instance of the database
            PropertyInfo property = databaseType.GetProperty("Instance", BindingFlags.Public | BindingFlags.Static);
            object database = property?.GetValue(null);

            // Check if database is not null
            if (database == null)
            {
                Guard<ValidationLogConfig>.Error(
                    $"Cannot register {obj.name} in {databaseSubtype.Name} ({databaseType.Name}). Database instance not found. " +
                    $"Are you sure it has public 'Instance' property?");
                return;
            }

            // Get method to register object
            MethodInfo registerMethod = databaseSubtype.GetMethod("Add");
            MethodInfo checkMethod = databaseSubtype.GetMethod("Contains");

            // Check if method is not null
            if (registerMethod == null || checkMethod == null)
            {
                Guard<ValidationLogConfig>.Error(
                    $"Cannot register {obj.name} in {databaseSubtype.Name}. 'Add' or 'Contains' method not found. " +
                    $"Are you sure it exists and is public?");
                return;
            }
            
            try
            {
                // Get object to register
                object objToRegister = getRegistryObjectRequestAction(obj, foundBaseClass, registerAttribute);
                
                // Ensure object is not already registered
                if (checkMethod.Invoke(database, new[] {objToRegister}) is true)
                    return;

                // Register object in database (add kvp)
                registerMethod.Invoke(database, new[] {objToRegister});

                Guard<ValidationLogConfig>.Debug(
                    $"Registered {obj.name} in {databaseSubtype.Name} database.");
            }
            catch (Exception exception)
            {
                Debug.LogError(exception);

                // Warn that adding failed, probably trying to add Addressable Asset to non-addressable
                // database.
                Guard<ValidationLogConfig>.Warning(
                    $"Failed to register {obj.name} in {databaseSubtype.Name}. " +
                    $"Are you trying to add Addressable Asset to non-addressable database?");
            }
        }
        
        private static object GetAddressableObjectToRegister([NotNull] Object obj, [NotNull] Type foundBaseClass,
            AutoRegisterInAttribute registerAttribute)
        {
            // Get reference to object
            (string address, AssetReference reference) = obj.GetAssetReference(foundBaseClass);

            // Prepare reference to be proper one
            Type assetReferenceTType = typeof(AssetReferenceT<>).MakeGenericType(foundBaseClass);
            object assetReferenceT = reference.CastToReflected(assetReferenceTType);

            // Create new KeyValuePair instance to be used in Contains and Add methods 
            object[] parameters = {address, assetReferenceT};
            object kvp = Activator.CreateInstance(
                typeof(AddressableReferenceEntry<>).MakeGenericType(foundBaseClass),
                parameters);
            
            return kvp;
        }

        private static (bool, ScriptableObject) TryCreateScriptableObject(Type type)
        {
            // Check if type is scriptable object
            if (!typeof(ScriptableObject).IsAssignableFrom(type)) return (false, null);

            // Check if type has AutoCreatedObjectAttribute
            AutoCreatedObjectAttribute attribute =
                CustomAttributeExtensions.GetCustomAttribute<AutoCreatedObjectAttribute>(type, true);
            if (attribute == null) return (false, null);

            // Ensure type is sealed, if not log warning and process further
            if (!type.IsSealed)
            {
                Guard<ValidationLogConfig>.Warning(
                    $"Type {type.Name} is not sealed. Non-sealed types are unsafe. Please add 'sealed' keyword to the class.");
            }

            // We can't create generic types, this will result in big no-no
            // Abstract generic types are fine because they won't pass to this check
            // as are ignored earlier. 
            if (type.IsGenericType)
            {
                Guard<ValidationLogConfig>.Error(
                    $"Type {type.Name} is generic. Generic types are not supported for auto-creation.");
                return (false, null);
            }

            // Get path to asset
            string assetDirectory = ValidateAndGetDirectoryPath(attribute);

            // Check if asset already exists
            // Skip if it does
            if (CheckIfExists(assetDirectory, type)) return (false, null);

            // Create scriptable object  
            ScriptableObject obj = ScriptableObject.CreateInstance(type);

            // Save object 
            AssetDatabase.CreateAsset(obj, $"{assetDirectory}{type.Name}.asset");
            Guard<ValidationLogConfig>.Debug($"Created {type.Name} at {assetDirectory}{type.Name}.asset");

            return (true, obj);
        }

        private static string ValidateAndGetDirectoryPath(AutoCreatedObjectAttribute attribute)
        {
            string subDirectory = attribute.SubDirectory;

            // Check if root directory exists
            if (!AssetDatabase.IsValidFolder(ROOT_PATH))
                AssetDatabase.CreateFolder("Assets", "AutoGenerated");

            string currentPath = ROOT_PATH;

            // Check if sub directory exists
            string[] splitDir = subDirectory.Replace('\\', '/').Split('/');

            // Create sub directories
            for (int j = 0; j < splitDir.Length; j++)
            {
                currentPath = currentPath.TrimEnd('/');

                // Create directory if it doesn't exist  
                if (!AssetDatabase.IsValidFolder(currentPath + "/" + splitDir[j]))
                {
                    AssetDatabase.CreateFolder(currentPath, splitDir[j]);
                    Guard<ValidationLogConfig>.Verbose($"Created missing folder: {currentPath}/{splitDir[j]}");
                }

                // Append new directory to path 
                if (!currentPath.EndsWith('/')) currentPath += '/';
                currentPath += splitDir[j];
            }

            // Ensure directory ends properly
            if (!currentPath.EndsWith('/')) currentPath += '/';

            return currentPath;
        }

        /// <summary>
        /// Checks if the asset already exists.
        /// </summary>
        private static bool CheckIfExists(string path, Type type) =>
            AssetDatabase.LoadAssetAtPath($"{path}{type.Name}.asset", type) != null;
    }
}