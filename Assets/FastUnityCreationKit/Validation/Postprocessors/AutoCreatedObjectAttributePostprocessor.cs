using System;
using System.Reflection;
using FastUnityCreationKit.Utility;
using FastUnityCreationKit.Utility.Attributes;
using FastUnityCreationKit.Utility.Logging;
using UnityEditor;
using UnityEngine;
using Assembly = System.Reflection.Assembly;


namespace FastUnityCreationKit.Validation.Postprocessors
{
    public class AutoCreatedObjectDeletionPostprocessor : AssetModificationProcessor
    {
        private static AssetDeleteResult OnWillDeleteAsset(string assetPath, RemoveAssetOptions options)
        {
            // Get asset type
            Type type = AssetDatabase.GetMainAssetTypeAtPath(assetPath);

            // Check if asset is scriptable object
            if (!typeof(ScriptableObject).IsAssignableFrom(type)) return AssetDeleteResult.DidNotDelete;

            // Check if asset has AutoCreatedObjectAttribute
            AutoCreatedObjectAttribute attribute = type.GetCustomAttribute<AutoCreatedObjectAttribute>(true);
            if (attribute == null) return AssetDeleteResult.DidNotDelete;

            // Fail deletion
            Guard<ValidationLogConfig>.Warning(
                $"Cannot delete {type.Name} asset. It is marked as auto-created object.");
            return AssetDeleteResult.FailedDelete;
        }
    }

    public class AutoCreatedObjectAttributePostprocessor : AssetPostprocessor
    {
        public const string ROOT_PATH = "Assets/AutoGenerated";

        private static void OnPostprocessAllAssets(string[] importedAssets,
            string[] deletedAssets,
            string[] movedAssets,
            string[] movedFromAssetPaths)
        {
            // We are primarily interested in new and deleted scripts 
            int totalCount = CountScripts(importedAssets) + CountScripts(deletedAssets) + CountScripts(movedAssets);
            Guard<ValidationLogConfig>.Verbose($"Processing scripts. Found {totalCount} modifications.");

            // Check if any scripts were altered
            if (totalCount == 0) return;
            Guard<ValidationLogConfig>.Verbose("Scripts modifications found, searching for objects to create.");

            PerformProcessing();
        }

        /// <summary>
        /// Count scripts modified in specified assets.
        /// </summary>
        private static int CountScripts(string[] assets)
        {
            // Count scripts
            int count = 0;
            for (int index = 0; index < assets.Length; index++)
            {
                string asset = assets[index];
                if (asset.EndsWith(".cs")) count++;
            }

            return count;
        }

        /// <summary>
        /// Perform processing of all assemblies.
        /// </summary>
        internal static void PerformProcessing()
        {
            // Get all assemblies
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();

            // Process all assemblies
            foreach (Assembly assembly in assemblies)
                OnAssemblyCompilationFinished(assembly);
        }

        private static void OnAssemblyCompilationFinished(Assembly assembly)
        {
            int createdCount = 0;

            // Load the compiled assembly
            Guard<ValidationLogConfig>.Verbose($"Loaded assembly {assembly.FullName}.");

            // Process all types with the custom attribute 
            foreach (Type type in assembly.GetTypes())
            {
                // Check if type is abstract or interface  
                if (type.IsAbstract || type.IsInterface) continue;

                // Check if type is scriptable object
                if (!typeof(ScriptableObject).IsAssignableFrom(type)) continue;

                // Check if type has AutoCreatedObjectAttribute
                AutoCreatedObjectAttribute attribute = type.GetCustomAttribute<AutoCreatedObjectAttribute>(true);
                if (attribute == null) continue;

                // Ensure type is sealed, if not log warning and process further
                if (!type.IsSealed)
                {
                    Guard<ValidationLogConfig>.Warning(
                        $"Type {type.Name} is not sealed. Non-sealed types are unsafe. Please add 'sealed' keyword to the class.");
                }

                // We can't create generic types, this will result in big no-no
                // Abstract generic types are fine because they won't pass to this check
                // as are ignored earlier. 
                if (type.IsGenericType)
                {
                    Guard<ValidationLogConfig>.Error(
                        $"Type {type.Name} is generic. Generic types are not supported for auto-creation.");
                    continue;
                }
                
                // Get path to asset
                string assetDirectory = ValidateAndGetDirectoryPath(attribute);

                // Check if asset already exists
                // Skip if it does
                if (CheckIfExists(assetDirectory, type)) continue;

                // Create scriptable object  
                ScriptableObject obj = ScriptableObject.CreateInstance(type);

                // Save object 
                AssetDatabase.CreateAsset(obj, $"{assetDirectory}{type.Name}.asset");
                Guard<ValidationLogConfig>.Debug($"Created {type.Name} at {assetDirectory}{type.Name}.asset");

                createdCount++;
            }

            // Log the number of created assets 
            if (createdCount > 0)
                Guard<ValidationLogConfig>.Debug($"Created {createdCount} assets from assembly {assembly.FullName}.");


            // Save assets that were created
            // we do this to ensure that the assets are saved
            //
            // We do this after all assets are created
            // to avoid saving assets multiple times
            AssetDatabase.SaveAssets();
            AssetDatabase.Refresh();
        }

        private static string ValidateAndGetDirectoryPath(AutoCreatedObjectAttribute attribute)
        {
            string subDirectory = attribute.SubDirectory;

            // Check if root directory exists
            if (!AssetDatabase.IsValidFolder(ROOT_PATH))
                AssetDatabase.CreateFolder("Assets", "AutoGenerated");

            string currentPath = ROOT_PATH;

            // Check if sub directory exists
            string[] splitDir = subDirectory.Replace('\\', '/').Split('/');

            // Create sub directories
            for (int j = 0; j < splitDir.Length; j++)
            {
                currentPath = currentPath.TrimEnd('/');

                // Create directory if it doesn't exist  
                if (!AssetDatabase.IsValidFolder(currentPath + "/" + splitDir[j]))
                {
                    AssetDatabase.CreateFolder(currentPath, splitDir[j]);
                    Guard<ValidationLogConfig>.Verbose($"Created missing folder: {currentPath}/{splitDir[j]}");
                }

                // Append new directory to path 
                if (!currentPath.EndsWith('/')) currentPath += '/';
                currentPath += splitDir[j];
            }

            // Ensure directory ends properly
            if (!currentPath.EndsWith('/')) currentPath += '/';

            return currentPath;
        }

        /// <summary>
        /// Checks if the asset already exists.
        /// </summary>
        private static bool CheckIfExists(string path, Type type) =>
            AssetDatabase.LoadAssetAtPath($"{path}{type.Name}.asset", type) != null;
    }
}